Implementation Details
======

**This document discusses the implementation of the Parsafix prototype.**

Parts
------
The prototype implementation consists of 5 main parts that each have their own function.\
They are listed below along with their corresponding files in the repository.

1. **Main**\
    The part that ties everything together and is used to start up Parsafix.
    - *index.js*

2. **Modelix client**\
    The part that handle communication with Modelix.
    - *modelixClient.js*
    - *modelixSubscription.js*
    - (*modelixProxy.js* for testing purposes)

3. **Saros client**\
    The part that handles communication with Saros.
    - *sarosClient.js*
    - *sarosProxy.js*

4. **Parser**\
    The part that handles the parsing of data to and from Modelix and Saros.
    - *parser.js*

5. **Webpage**\
    The part that generates a web page that allows you to view the parsing steps happening inside Parsafix.
    - *httpServer.js*
    - *www/**

Additionally the repository contains the _tools.js_ file, which is essentially a little library of functions used by multiple other files in the repository.

Each part and its files are explained in more detail below.

*Part 1:* Main
------
The prototype is made up of multiple parts that perform different functions. These parts need to be tied together somewhere so that they can communicate with one another and work in unison. That is what the *main* part of the implementation is for.

Inside the __*index.js*__ file, the following things take place:
- The Modelix client, Saros client, parser and webpage parts are instantiated
- The instantiated parts are started
- Data that is received (from some part) is passed onto its destination parts

Running the _index.js_ file starts up Parsafix. This is done by running the following command using a terminal inside the directory:
`node index.js mps spoofax`

If you only want to start up the MPS side, run `node index.js mps` instead, or if you only want to start up the Spoofax side, run `node index.js spoofax`.

Starting Parsafix will cause Node.js to open various connections, which should be closed upon shutting Parsafix down. To stop Parsafix, type _ctrl+C_ into the terminal. It will ask you `Are you sure you want to exit? (y/n)`. Typing `y` and pressing return will make Parsafix close its connections and shut down. Any other input will leave the tool running.

*Part 2:* Modelix client
------
The Modelix client part connects to a Modelix server and poses as an MPS client. It should be noted that there is a difference between the Modelix _server_ and the Modelix _plugin_. The Modelix _plugin_ lives inside an MPS client and communicates with the Modelix _server_. The Modelix server is where the collaborative project of the MPS clients is stored. By connecting to it, Parsafix can access and alter the collaborative MPS project.

The Modelix server provides an API that can be accessed using HTTP requests. The API calls can be found [here](https://github.com/modelix/modelix/tree/master/model-server). The way these API calls work has to do with the way Modelix stores project data in its database. Ultimately the API boils down to the following: a client sends the Modelix server a key, which it looks up in its database and as a response it sends back the corresponding value. This idea is seemingly simple, but the way in which the keys correspond with project data is quite complex, which is explained in the following section.

### Hash Array Mapped Trie (HAMT)
The Modelix server stores project data in the form of a HAMT. Put simply, a HAMT is a way of making a tree structure faster to navigate by means of hash keys, but saves memory compared to a regular hash tree/table. It boils down to a collection of arrays that point to each other, thereby forming a type of tree structure.

The Modelix HAMT contains 3 types of nodes in its "tree".
1. Internal nodes
2. Leaf nodes
3. Content nodes

An internal nodes contains an array consisting of pointers to other nodes.\
A leaf node contain 2 things: the key of an MPS AST element and a pointer to the element's content.\
A content node contain the properties of an MPS AST element.

The pointing in the Modelix HAMT is done through the use of custom hashes generated by Modelix. Each node in the HAMT has a unique hash that points to it. All hashes have the same length and character range, but to differentiate between the different node types the hashes can point to, I will be calling them _internal_, _leaf_ and _content hashes_. To summarize:
- An _internal hash_ points to an internal node.
- A _leaf hash_ points to node's key and its content hash.
- A _content hash_ points to the node's content (its properties).

To construct the HAMT from the MPS project (which is an AST), Modelix does the following:
1. Each node of the AST is assigned a key 
2. A hash is generated for the content of each node
3. A new array is created and each AST node is assigned an index in the newly created array, based on its key.
4. A _leaf hash_ is generated as a pointer to the node's key and content hash.
5. If there is nothing present at the node's assigned index, the leaf hash is stored in the array at the assigned index.
6. If there is already an existing hash at the node's assigned index, a new array is created. The existing hash and the new leaf hash are stored inside the new array.
An _internal hash_ is generated for the new array, which is stored as a pointer to the new array in the original HAMT array.

Depending on the size of the MPS project's AST, the HAMT can grow to be quite large, with internal nodes that contain internal nodes, containing more internal nodes etc. The diagram below illustrates this.

                    <internal hash>
                           |
                          \|/
           |<internal hash>|<leaf hash>|<internal hash>|
                   |                                |
                  \|/                              \|/
       |<leaf hash>|<internal hash>|    |<leaf hash>|<leaf hash>|
                           |
                          \|/
               |<leaf hash>|<leaf hash>|

Note that the root of the HAMT is an _internal hash_ pointing to the shallowest internal node.

### Reconstructing the MPS AST
Parsafix's initial goal in communicating with the Modelix server is to locally reconstruct the MPS project AST from the data it receives from the server.\
_NOTE: this project AST should not yet contain any models. MPS treats the project as a whole as an AST. Models are added to this AST in a later stage._

Initially we're trying to get the internal hash of the shallowest internal node, which will point us to all other nodes in the HAMT. Modelix can support multiple projects at once, which are split up into "branches". For the purpose of the prototype we're only working with a single project at a time, so we're only interested in the default branch, which is where our project will reside. The so-called _tree hash_ of the default branch is the internal hash we're looking for.

Inside _**modelixClient.js**_ the following steps are taken:
1. A new socket is opened and a connection is made with the Modelix server.
2. *A HTTP POST request for a client ID is sent to the server
3. *Upon receiving a client ID (note: which is never used), a request for the repository ID is sent.
4. Upon receiving the repository ID (note: which is never used), a request for the default branch information is sent.
5. Upon receiving the default master branch information, which is the aforementioned _internal hash_ of the default branch, it is used iteratively to request the data of all the nodes in the HAMT.

*I did not investigate whether these steps are truly necessary, but they are performed by regular MPS clients.

Sending the _internal hash_ of the branch to the Modelix server gives us the internal node it points to. We can then individually send the hashes contained in the internal node as requests to the server, which will give us the data the hashes point to. We do this until we have obtained all the content nodes in the HAMT (this is handled by the `collectTreeData()` function). At that point we have all the information necessary to reconstruct the MPS AST.

During all this, Parsafix also reconstructs the Modelix server's HAMT inside the `hamt` object.

### Subscribing to updates
Once we have reconstructed the MPS AST, Parsafix needs to stay informed about the changes that are made to the project by the collaborating MPS clients. The _**modelixSubscription.js**_ file serves this purpose. Once all the MPS AST data has been collected, the class contained in this file is instantiated and started. It performs the following steps:

1. A new socket is opened for receiving subscription data
2. A subscription request is sent to the Modelix server
3. When subscription data comes in, an event is emitted that triggers *modelixClient.js* to handle that data

### Handling subscription data

Subscription data is a key (a hash) that corresponds with the properties of the update that was performed. In the Modelix code, the update properties are bundeled in an object referred to as a _CPVersion_. Upon receiving subscription data, Parsafix sends the key back to the Modelix server, which responds with the corresponding _CPVersion_. The _CPVersion_ is reconstructed by Parsafix with the function `constructCPVersion()`.

The _CPVersion_ contains several properties, such as an update ID and timestamp, but most importantly, it contains the operations that were performed in the update. In order to stay synchronized with the Modelix server, Parsafix must perform these operations on its local version of the MPS AST. It does this inside the `handleOperation()` function. The possible operations are:
- `AddNewChildOp` which adds a new node to the AST
- `DeleteNodeOp` which removes a node from the AST
- `MoveNodeOp`* which changes the location of a node in the AST
- `NoOp` which does nothing
- `SetPropertyOp` which alters a node property
- `SetReferenceOp` which alters a reference to another node in the AST
- `UndoOp`* which undoes a previous operation.

*Parsafix does not currently fully support these operations

Parsafix also updates its local version of the Modelix HAMT, which is changed whenever an operation is performed. The function `tools.updateInternalNode()` is used for this.

### Sending updates to the Modelix server

The logic in the _modelixClient.js_ file also takes care of updating the Modelix server with changes made to the collaborative project by the Spoofax side. When this happens, an event is triggered that calls the `handleParsafixEdit()` function. This function is passed all the data necessary to generate an update to send to Modelix. 

Currently, three types of operations are supported: 
- `AddNewChildOp` to add a new node, with the function `addNewNode()`
- `DeleteNodeOp` to delete an existing node, with the function `deleteNode()`
- `SetPropertyOp` to update a node property, with the function `setNodeProperty()`

These functions also update the local version of the Modelix HAMT (the `hamt` object), because the new updated HAMT must be sent as part of the update to the Modelix server. Inside the _tools.js_ file, there are multiple functions that were taken more or less directly from the Modelix plugin source code. These functions are `logicalToPhysicalIndex()`, `isBitNotSet()`, `put()`, `getChildNodeHash()`, `setChild()` and `deleteChild()`. These functions are used by Parsafix to mimic what the Modelix plugin would do for an MPS client when updating its HAMT.

It should be noted that Modelix does not distinguish between the client that sent an update and the clients that need to receive it. So after sending Modelix an update, our own update is sent back to us by the server as subscription data. At this point Parsafix updates its local MPS AST.\
However, seeing as we already updated the local version of the HAMT upon sending the update, the local HAMT must remain the same. This is currently achieved by keeping track of our own updates in the `parsafixOps` array, and ignoring those updates when it comes to updating the local HAMT.

### Modelix Proxy
It can be helpful to examine the data that is sent between a real MPS client and Modelix, so that we can compare it to the data we send to Modelix.\
For this purpose I have included the _**modelixProxy.js**_ file, which sits as a proxy between an MPS client and the Modelix server.\
To use it, follow the steps described in the section _Running Parsafix_ as normal, but before opening MPS, start the proxy server with the command `node modelixProxy.js`.\
Then, when connecting to the Modelix server "repository" inside MPS, as is described in the _Setting up Modelix_ subsection, connect to the proxy repository instead of the real one (it should appear below the real Modelix repository with port 28102 instead of 28101). Proceed like normal, but using this repository.\
All data sent back and forth between the MPS client and the Modelix server is saved to a file name _proxyTraffic.txt_ in the root folder. Happy debugging!

*Part 3:* Saros client
------
The Saros client part connects to a Saros host via an XMPP and poses as an Eclipse client.\
It should be noted that as opposed to Modelix, Saros does not have a dedicated server. A regular XMPP server is used that only serves the function of passing on incoming data. The Saros host, an Eclipse client, takes care of the collaboration logic such as making sure the other collaborating clients are synchronized.
All of the collaborating Eclipse clients keep a local version of the collaborative project, but the Saros host keeps the "true" version that all the other clients must remain consistent with. By connecting to the Saros host and being accepted into the collaborative session, Parsafix can access and alter the collaborative Eclipse project.

Saros makes use of the XMPP protocol, the specifics of which can be found [here](https://xmpp.org/rfcs/rfc3921.html). The XMPP protocol works by exchanging data between sender and receiver in the form of (small) xml messages called "stanzas". There are different kinds of default stanzas, namely _presence_, _message_ and _iq_ (Info/Query) stanzas, each of which serve a different standardized function, but stanzas can also be completely custom-made. A stanza will look something like this:\
`<type attribute="attribute value"><some_element>An element payload</some_element></type>`

### Saros Negotiation Process

In order for Parsafix to be accepted into a collaborative Saros session by the Saros host, it must follow the steps of the Saros negotiation process. These steps can be found in various places in the Saros source code, but I will list them here for convenience. These steps take place when a client is added to a Saros session:

1. The host checks whether Saros is available on the client's side. 
2. The host checks whether the client's Saros is compatible with own version.
3. The host sends a session invitation offering to the client.\
   The client sends back an invitation acknowledgement to the host (if not currently in another session).
4. The clients sends an invitation acceptance to the host.
5. The client creates a "wishlist" with session parameters and sends it to the host.
6. The host considers these preferences and sends the settled session parameters back to the client.
7. The client initializes the session and related components (e.g. chat, color management) with the parameters as defined by the host. The session is created locally (but not started yet).
8. The clients establishes a [SOCKS5 bytestream connection](https://xmpp.org/extensions/xep-0065.html) with the host. If this fails, an [IBB connection](https://xmpp.org/extensions/xep-0047.html) is established instead.
9. The host opens the connection.
10. The client uses the new connection to signal to the host that the session invitation is complete.
11. The host formally adds the client to the session so that the client will receive activities. The host sends a final acknowledgement to client.
12. The host sends the user list (clients that make up the session) to the client.
13. The client acknowledges the user list. At this point the client can start working in the session.

### Connecting to the Saros host

In the _**sarosClient.js**_ file, Parsafix connects to the XMPP server by performing the following steps in the `handleXMPP()` function, which is called from its constructor:
1. An XMPP handshake is initiated with the server
2. Upon being authorized by the server, we announce our presence to all other clients connected to the XMPP server in order to signal Parsafix's availability for communications
3. Then we send an XMPP stanza telling the other clients what version of Saros we're using (version 16.0.1)

At this point Parsafix will appear as "online" in the Saros plugin view inside the Eclipse IDE of the Saros host.
Now that Parsafix has come online, it must be added manually to the Saros session by the host. After doing so, Parsafix takes the steps listed below (taking place inside the `handleMessageStanza()` function). The corresponding steps from the Saros Negotiation Process (see previous section) are listed alongside them.

1. Parsafix receives a session invitation (called a Session Negotiation Offering, or "snof") [3].\
   Parsafix responds with a Session Negotiation Acknowledgement, or "snak" message.
2. Parsafix sends a Session Negotiation Acceptance, or "snac" message to the host [4].
3. Parsafix sends a Session Negotiation Parameter Exchange, or "snpe" message to the host [5].
4. Upon receiving a "snpe" response message from the server in return, Parsafix sends the host an IQ stanza telling it the address of its proxy server [8].

Besides connecting to the host, the constructor of the _SarosProxy_ class also starts up a proxy server that listens on a given port. This proxy server is necessary for peer-to-peer data exchange between Parsafix and the host, which becomes necessary at this point in the process. The XMPP server only plays an important role in the initial contact between the host and Parsafix. After that a connection is established between Parsafix's proxy server and a proxy server generated by the host, which directly share data with one another. 
The next steps take place inside _**sarosProxy.js**_, as does the rest of Parsafix's communication with the Saros host.

5. The host attempts to open a SOCKS5 connection to the proxy server. Parsafix handles the SOCKS5 handshake inside the `handleHandshake()` function [9].
6. Once the connection has been established, Parsafix sends the host a SOCKS5 bytestream message containing a Session Negotiation Complete, or "sncmp" message [10].
7. The host sends Parsafix the user list, which Parsafix accepts by sending back a "ulsups" message as a bytestream over the SOCKS5 connection [12 & 13].

From here on out, Parsafix is sent an update via the SOCKS5 connection every time an Eclipse client makes a change to the Eclipse project in the collaborative Saros session.

### SOCKS5 Bytestreams

The specifics of the SOCKS5 protocol can be found [here](https://xmpp.org/extensions/xep-0065.html).

I will briefly discuss what the data looks like that the Saros host sends and expects to receive over the SOCKS5 peer-to-peer connection.\
Data exchange using the SOCKS5 protocol is done by sending bytestreams, meaning that a sequence of bytes is sent to the receiver over TCP.\
JavaScript is not ideal for working with bytestreams, but it can be done with Node.js, through the use of a so-called [_Buffer_](https://nodejs.org/api/buffer.html) object. In order to convert a string into a sequence of bytes, Parsafix must translate it into a Buffer object.

The sequence of bytes are treated as a sequence of hexadecimal numbers (each byte represents a single hexadecimal number). Put together, the hexadecimal numbers form messages. Every type of message has a corresponding "operation code", which is used to distinguish between message types. Below are the 4 different bytestream message types with their corresponding operation codes in hexadecimals:
1. An element name update (FB)\
   *The name of the XMPP stanza being sent (e.g. "sncmp" or "ulsups")
2. A namespace update (64)\
   *The namespace, which is just "Saros" in our case
3. A transfer description (FA)\
   *Tells the Saros plugin how to send the message
4. Data (65)\
   *Contains an XMPP stanza

*The payload of these messages are strings converted to hexadecimals.

A bytestream can contain any number of these messages strung together. Each message starts with its operation code (1 byte), followed by the messages properties and payload, which also have a designated number of bytes. The functions `handleElementNameUpdate()`, `handleNamespaceUpdate()`, `handleTransferDescription()` and `handleData()` elaborate on what the rest of the bytes in the message are used for. Alternatively this information is also found in [this file](https://github.com/saros-project/saros/blob/master/core/src/saros/net/internal/BinaryChannelConnection.java) in the Saros source code.

The Saros host doesn't send the sequence of bytes over the network as is. The bytestream is first _deflated_ (compressed) using [zlib](https://nodejs.org/api/zlib.html). Therefore, when a bytestream is received from the Saros host, it must first be _inflated_ (decompressed) again before Parsafix can read its data. In the opposite direction, Parsafix must first deflate a bytestream before it sends it to the Saros host.

_NOTE: Parsafix does not currently support Saros's fallback method of switching to an IBB connection if the SOCKS5 connection fails_ [8].

### Sending updates to the Saros host

The logic in the _sarosProxy.js_ file also takes care of updating the Saros host with changes made to the collaborative project by the MPS side. When this happens, an event is triggered that calls the `handleParsafixEdit()` function. This function is passed all the data necessary to generate an update to send to Eclipse.

Currently, two types of MPS operations are supported. They are translated to three possible Saros operation types in this step (_This could perhaps also be done earlier in the process_). 
- `AddNewChildOp` to either add a new file with the function `createFile()`, or add a new line of text with the function `insertText()`
- `SetPropertyOp` to either add text to an exisiting line with the function `insertText()`, or to delete existing text with the function `deleteText()`

Operations that alter the collaborative Eclipse project are communicated with stanzas of type "ados". I'm not sure what that stands for, but the comments in the Saros source code calls them _Activities Extensions_. I will refer to them as _activites_. The bytestream that is sent to communicate an activity consists of a _Transfer Description_ message, followed by a _Data_ message containing the activity stanza. The functions listed above will tell you what the bytestream looks like exactly, but put briefly:

- All updates must contain the session ID of the current Saros session, as well as the project ID of the collaborative project. These IDs are received from the Saros host when it connects to the proxy server.
- All updates must contain a sequence number, which is the number of activities that have been sent to the Saros host by Parsafix over the course of the Saros session
- For adding a new file to the Eclipse project, a file name must be given
- For inserting text the following must be given: the text to insert, the line index and offset of where the new text must go, and how often this file has been edited by the host and the client
- For deleting text the following must be given: the text to delete, the line index and offset of where the text must be removed from, and how often this file has been edited by the host and the client

Additionally, the functions `activateEditing()`, `stopEditing()` and `saveFile()` exist. These functions send messages to the Saros host that tell it the following respectively: that Parsafix is editing a specific file, that Parsafix has stopped editing a specific file and that a file must be saved. However, sometimes "activating editing" makes it so that Parsafix's updates don't come through. Saving only seems to be necessary in order for the host to accept the update when adding a new file/line, not when editing existing text. I haven't had time to find out the exact rhyme or reason behind the use of these messages. In any case, regular Eclipse clients send these types of messages too, so I have implemented them.

*Part 4:* Parser
------
The Parser part takes care of converting MPS data to Eclipse data and vice versa, through the use of an intermediate data model that I will refer to as the _Parsafix data model_.
Put simply, when data comes in from Modelix, Parsafix updates its _MPS data model_, maps it to the _Parsafix data model_ and then generates an update for the _Spoofax data model_, which is passed onto the _Saros client_ class to be sent to the Saros host so that the collaborating Eclipse clients are synchronized with Parsafix.
When data comes in from Saros, more or less the opposite happens. Parsafix updates its _Spoofax data model_, maps it to the _Parsafix data model_ and then generates an update that is passed onto the _Modelix Client_ class to be sent to the Modelix server so that the collaborating MPS clients are synchronized with Parsafix. A small difference here is that the parser wait's for the _Modelix Client_ class to process the update and return generated update details before it updates the _MPS data model_.

All the parsing takes place inside the _**parser.js**_ file.\
_Note: currently several functions inside this file are hardcoded to support a specific DSL (Generic DSL). These functions should be made generic in the future._

### Parsing MPS to Spoofax

_NOTE: Parsafix assumes that the Modelix session it joins starts out without models in. It does not currently fully support processing existing models._

When Parsafix is done reconstructing the initial MPS AST (see the corresponding section under the Modelix client part), this AST is passed onto the parser by the _Modelix client_ class. The parser treats this AST as its _MPS data model_.

When the parser receives an "edit operation" from the _Modelix client_ class, i.e. an update to the MPS AST, the parser takes the steps described below. This takes place inside the `mpsOperation()` function.

1. Parsafix examines what type of operation its dealing with\
   _Currently not all operations are supported and the ones that are supported are treated the same for convenience. This should be split apart in the future._
2. Inside the `handleMpsAddSetDeleteNodeOp()` the following takes place:\
      Depending on the operation type, preparations are made for mapping the operation onto the _Parsafix data model_, such as finding the corresponding model and the operation node's parent.\
      If the operation is the deletion of a node from the MPS AST, the node is deleted from the _Parsafix data model_.\
      The _MPS data model_ is replaced by the updated MPS AST (which is received from the _Modelix client_ class).
3. If the operation was of type `addNewChildOp` or `setProperty`, Parsafix moves onto the `mapMpsIdlElement()` function, where the following takes place:\
      Using the `editMappedElement()` function, the operation is mapped to the _Parsafix data model_. This is a matter of either creating a new model inside the _Parsafix data model_, adding a new child to an exisiting element, or updating a property of an existing element. Admittedly, this function is a little convoluted and requires a refactor ASAP.
4. The update to the _Parsafix data model_ is passed onto the _Saros client_ to be sent to the Saros host, by the function `parsafixToSpoofaxEdit()`.

### Parsing Spoofax to MPS

_NOTE: Parsafix assumes that the Saros session it joins starts out without DSL files in it. It does not currently fully support processing existing files._

Seeing as the Spoofax project starts out empty, there is nothing for the parser to do initially. Therefore it waits for Spoofax updates to come in.\
When an update comes in, the `spoofaxToParsafix()` function is triggered. From there on out, the following takes place:

1. Parsafix replaces the _Spoofax data model_ with the new text that it receives from the _Saros client_ class. Then it examines what type of operation its dealing with\
   _Currently Parsafix only supports Saros's insertOp and deleteOp. These are treated the same because they are only slightly different._
2. Inside the `handleSpoofaxInsertDeleteOp()` preparations are made for mapping the operation onto the _Parsafix data model_. This means finding the corresponding model or adding a new one if it doesn't exist yet.
3. Next Parsafix moves onto the `mapLine()` function, which looks at the line that the operation took place on.\
   _NOTE: currently we assume that an operation takes place on a single line. Multi-line deletions and the like are not currently supported._\
   Parsafix does the following here:\
      It tries to match the line with the given regular expressions belonging to the DSL (Generic DSL in this case).
      If no match is found, the line is treated as a "comment", which boils down to ignoring it.
      If a match is found, Parsafix moves onto the `mapSpoofaxIdlElement()` function.
4. Inside the `mapSpoofaxIdlElement()` function, the `editMappedElement()` function is used to either update an existing element in the _Parsafix data model_ that corresponds with the line, or a new element is added.
5. Finally, the `parsafixToMpsEdit()` is used to pass the update in the _Parsafix data model_ onto the _MPS client_ to be sent to Modelix.

*Part 5:* Webpage
------
Put together, the parts described above can be overwhelming and hard to follow. For this reason, I have added to Parsafix a local HTTP server that hosts a simple webpage. On this webpage the _MPS data model_, _Parsafix data model_ and _Spoofax data model_ (described in the Parser section) can be viewed. The webpage is updated every time Parsafix processes an update from either Modelix or Saros. I found this helpful to keep track of what Parsafix is doing behind the scenes.

The _**httpServer.js**_ file starts up the HTTP server. The files inside the _**www**_ directory make up the files of the webpage.

Once Parsafix is started up, view the webpage by navigating to _localhost:38101_.\
The choice of port number here has no significance. Change it if you like. It was easy to remember because the first digit is 1 greater than the default port used by the local Modelix server (28101). 

_Note: If a web browser is already on the webpage when Parsafix is started up, it might not realize it is receiving new webpage updates. Reload the webpage to solve this._

Logging
------
Of course, the webpage described above is not enough to keep track of everything that is happening. Parsafix has become quite complex and a lot can go wrong. For this reason I have implemented a rudimentary logging system that keeps logs about the communication between Parsafix and Modelix/Saros. These logs are stored inside the _**logs**_ directory. Log files pertaining to Modelix start with "mps" and logs pertaining to Saros start with "spoofax", followed by the date.

The log messages are also displayed in the terminal running Parsafix. This can be turned on and off inside the _index.js_ file, at the instantiation of the _Modelix client_ and the _Saros client_. If their second parameters are `true`, the logs will be displayed in the terminal, if `false` they will not. Log files are always stored.

Known Issues and Future Work
------
As mentioned in the _disclaimer_ in the root README, this prototype is far from perfect. Below is a list of points that should be addressed when continuing to develop the Parsafix tool.

- I did not get around to implementing node deletion. On the Modelix side, nodes can be deleted using the `deleteNode()` function, but this function is not used yet (although it does work). So when a model element gets deleted on the Eclipse side, Parsafix does not request a node deletion from Modelix yet. The same goes for the other direction, when an MPS node gets deleted, Parsafix does not yet ask Saros to remove any code in the Eclipse editor. The `deleteText()` function should be used for this.
- The Modelix client side of Parsafix is unstable. Modelix is extremely finicky about the data it receives and loves to crash. I have spent weeks peering at the Modelix source code and the data sent between client and server as well as troubleshooting the Modelix side of the Parsafix implementation. I have gotten it to a point where it usually works, but not always. I strongly suggest contacting [Sascha Lisson](https://github.com/slisson) at Itemis (creator of Modelix) about the intricacies of Modelix, instead of trying to figure it all out by yourself (like I did). The comments in the code should offer some indication as to what it going on, but it can be quite overwhelming.
- For some reason the updates Parsafix sends to Modelix take a long time to appear inside of the editor of the MPS client. I tested it, Parsafix processes a Saros update and sends it to Modelix almost instantaneously, so it's not due to Parsafix doing some complex operation that takes too long. Updates going in the other direction (from MPS to Eclipse) do appear inside the Eclipse editor immediatly, as expected. Perhaps Modelix expects slightly different update messages after all? That would be strange, because Parsafix merely mimics the updates that a regular MPS clients sends to Modelix. Once again, I suggest asking [Sascha Lisson](https://github.com/slisson) at Itemis about it.
- Implement some form of error handling for when updates from Modelix or Saros do not come through properly.\
  Currently this problem chiefly occurs on the Saros side. If an insertion/deletion update does not reach Parsafix, Parsafix's _Spoofax data model_ becomes incosistent with that of the Saros host, which will cause issues when sending future updates to the Saros host. Perhaps the [Saros checksum functionality](https://github.com/saros-project/saros/blob/master/core/src/saros/activities/ChecksumActivity.java) can be used to achieve this.
- Currently Parsafix assumes that an Eclipse user will only ever edit 1 line at a time. If a user were to paste an entire block of code at once, the parser will not be able to handle it. This should be fixed.
- The Modelix HAMT inside Parsafix is currently just a JSON object. It should probably be implemented as a proper HAMT to improve efficiency.
- Parsafix currently only supports the Modelix default master branch. It should be made to support multiple Modelix branches.
- If the SOCKS5 connection between the Saros host and Parsafix fails, Saros falls back on IBB. Parsafix does not support this.

The following cannot be fixed inside Parsafix, but would make for a better integration with Spoofax.
- Currently Saros does not work well with the "Spoofax editor". Either Saros or Spoofax (or both) could be updated to fix the problems there. 
  I believe the problem may lie in that the _documentProvider_ used for the Spoofax editor implementation is not an instance of the _TextFileDocumentProvider_, as can be seen in [this file](https://github.com/saros-project/saros/blob/master/eclipse/src/saros/editor/EditorPool.java) of the Saros source code.
